/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CountCraftPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/constants.ts
var COUNTER_DEFINITIONS = [
  {
    type: "wordCount" /* WORD_COUNT */,
    name: "Word Count",
    description: "Counts the total number of words in the note",
    hasParameter: false
  },
  {
    type: "charCountWithSpaces" /* CHAR_COUNT_WITH_SPACES */,
    name: "Character Count (with spaces)",
    description: "Counts all characters including spaces",
    hasParameter: false
  },
  {
    type: "charCountWithoutSpaces" /* CHAR_COUNT_WITHOUT_SPACES */,
    name: "Character Count (without spaces)",
    description: "Counts characters excluding spaces and line breaks",
    hasParameter: false
  },
  {
    type: "lineCount" /* LINE_COUNT */,
    name: "Line Count",
    description: "Counts the total number of lines in the note",
    hasParameter: false
  },
  {
    type: "headingCount" /* HEADING_COUNT */,
    name: "Heading Count (All Levels)",
    description: "Counts all headings regardless of level",
    hasParameter: false
  },
  {
    type: "headingLevelCount" /* HEADING_LEVEL_COUNT */,
    name: "Heading Count (Specific Level)",
    description: "Counts headings of a specific level",
    hasParameter: true,
    parameterName: "Level",
    parameterType: "number",
    parameterMin: 1,
    parameterMax: 6
  }
];
var DEFAULT_SETTINGS = {
  calculations: [],
  ribbonEnabled: false,
  autoCalculate: false,
  debugMode: false
};
var COMMAND_IDS = {
  CALCULATE: "calculate-stats",
  OPEN_SETTINGS: "open-settings"
};
var ICONS = {
  RIBBON: "calculator",
  SETTINGS: "settings"
};
var MESSAGES = {
  CALCULATION_COMPLETE: "Calculation completed successfully!",
  NO_ACTIVE_FILE: "No active file to calculate statistics for",
  PROPERTY_CREATED: "Property created: ",
  DUPLICATE_CONFIG: "A calculation with this configuration already exists",
  INVALID_PARAMETER: "Invalid parameter value",
  CACHE_UPDATED: "Statistics updated from cache"
};
var DEFAULT_PROPERTY_NAMES = {
  ["wordCount" /* WORD_COUNT */]: "word-count",
  ["charCountWithSpaces" /* CHAR_COUNT_WITH_SPACES */]: "char-count-with-spaces",
  ["charCountWithoutSpaces" /* CHAR_COUNT_WITHOUT_SPACES */]: "char-count-without-spaces",
  ["lineCount" /* LINE_COUNT */]: "line-count",
  ["headingCount" /* HEADING_COUNT */]: "heading-count",
  ["headingLevelCount" /* HEADING_LEVEL_COUNT */]: "heading-level-count"
};

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils.ts
var PropertyManager = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Ensures a property exists in the vault's property registry
   */
  async ensurePropertyExists(propertyName) {
    const metadataTypeManager = this.app.metadataTypeManager;
    if (!metadataTypeManager) {
      return { name: propertyName, type: "number", exists: false };
    }
    const existingType = metadataTypeManager.getPropertyInfo(propertyName);
    if (existingType && existingType.type === "number") {
      return { name: propertyName, type: "number", exists: true };
    }
    try {
      await metadataTypeManager.savePropertyInfo(propertyName, { type: "number" });
      return { name: propertyName, type: "number", exists: true };
    } catch (error) {
      console.warn(`Could not create property ${propertyName}:`, error);
      return { name: propertyName, type: "number", exists: false };
    }
  }
  /**
   * Updates a file's property with a numeric value
   */
  async updateFileProperty(file, propertyName, value) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      frontmatter[propertyName] = value;
    });
  }
};
var CacheHelper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get file content excluding properties section (YAML)
   */
  async getFileBody(file) {
    const content = await this.app.vault.cachedRead(file);
    const cache = this.app.metadataCache.getFileCache(file);
    const fmPos = cache == null ? void 0 : cache.frontmatterPosition;
    if (!fmPos)
      return content;
    const lines = content.split(/\r?\n/);
    const bodyLines = lines.slice(0, fmPos.start.line).concat(lines.slice(fmPos.end.line + 1));
    return bodyLines.join("\n");
  }
  /**
   * Gets file content efficiently using cache when possible
   */
  /*     async getFileContent(file: TFile): Promise<string> {
          // Try to get cached content first for better performance
          const cache = this.app.metadataCache.getFileCache(file);
          
          if (cache?.sections) {
              // Use cached sections to reconstruct content if available
              return await this.app.vault.cachedRead(file);
          }
          
          // Fallback to direct read
          return await this.app.vault.read(file);
      } */
  /**
   * Gets cached metadata for a file
   */
  getCachedMetadata(file) {
    return this.app.metadataCache.getFileCache(file);
  }
  /**
   * Checks if file has cached headings
   */
  getCachedHeadings(file) {
    var _a, _b, _c, _d;
    const cache = this.getCachedMetadata(file);
    const fmEnd = (_c = (_b = (_a = cache == null ? void 0 : cache.frontmatterPosition) == null ? void 0 : _a.end) == null ? void 0 : _b.line) != null ? _c : -1;
    const headings = (_d = cache == null ? void 0 : cache.headings) != null ? _d : [];
    return headings.filter((h) => {
      var _a2, _b2;
      return ((_b2 = (_a2 = h.position) == null ? void 0 : _a2.start) == null ? void 0 : _b2.line) > fmEnd;
    });
  }
};
var ValidationHelper = class {
  /**
   * Validates counter configuration
   */
  static validateCounterConfig(config, existingConfigs) {
    var _a, _b;
    const prop = ((_a = config.property) != null ? _a : "").trim();
    if (!((_b = config.property) == null ? void 0 : _b.trim())) {
      return "Property name is required";
    }
    const isDuplicate = existingConfigs.some(
      (existing) => existing.id !== config.id && existing.property === prop
    );
    if (isDuplicate) {
      return `Property name "${prop}" is already used by another calculation`;
    }
    if (!config.type) {
      return "Counter type is required";
    }
    if (config.parameter !== void 0) {
      if (config.type === "headingLevelCount") {
        const level = Number(config.parameter);
        if (isNaN(level) || level < 1 || level > 6) {
          return "Heading level must be between 1 and 6";
        }
      }
    }
    return null;
  }
  /**
   * Generates unique ID for counter configuration
   */
  static generateCounterId() {
    return `counter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Sanitizes and Preserve Property Name
   */
  static sanitizePropertyName(name) {
    return name.trim();
  }
};
var TextAnalyzer = class {
  /**
   * Counts words in text using regex
   */
  static countWords(text) {
    const words = text.match(/\b\w+\b/g);
    return words ? words.length : 0;
  }
  /**
   * Counts characters including spaces
   */
  static countCharactersWithSpaces(text) {
    return text.length;
  }
  /**
   * Counts characters excluding spaces and line breaks
   */
  static countCharactersWithoutSpaces(text) {
    return text.replace(/\s/g, "").length;
  }
  /**
   * Counts lines in text
   */
  static countLines(text) {
    if (!text)
      return 0;
    return text.split(/\r?\n/).length;
  }
  /**
   * Extracts headings from text
   */
  static extractHeadings(text) {
    const headings = [];
    const lines = text.split(/\r?\n/);
    lines.forEach((line, index) => {
      const match = line.match(/^(#{1,6})\s+(.+)$/);
      if (match) {
        headings.push({
          level: match[1].length,
          heading: match[2].trim(),
          line: index + 1
        });
      }
    });
    return headings;
  }
  /**
   * Counts headings by level
   */
  static countHeadingsByLevel(text) {
    const headings = this.extractHeadings(text);
    const counts = {};
    headings.forEach((heading) => {
      counts[heading.level] = (counts[heading.level] || 0) + 1;
    });
    return counts;
  }
};
var DebugLogger = class {
  static enable(enabled) {
    this.enabled = enabled;
  }
  static log(message, data) {
    if (this.enabled) {
      console.log(`[CountCraft] ${message}`, data || "");
    }
  }
  static warn(message, data) {
    if (this.enabled) {
      console.warn(`[CountCraft] ${message}`, data || "");
    }
  }
  static error(message, error) {
    if (this.enabled) {
      console.error(`[CountCraft] ${message}`, error || "");
    }
  }
};
DebugLogger.enabled = false;
function errorMessage(e) {
  if (e instanceof Error)
    return e.message;
  try {
    return typeof e === "string" ? e : JSON.stringify(e);
  } catch (e2) {
    return String(e);
  }
}

// src/settings.ts
var EditCalculationModal = class extends import_obsidian.Modal {
  constructor(app, plugin, config, onSave) {
    super(app);
    this.plugin = plugin;
    this.config = { ...config };
    this.onSave = onSave;
    this.type = this.config.type;
    this.property = this.config.property;
    this.enabled = this.config.enabled;
    this.parameter = this.config.parameter;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.setTitle("Edit Calculation");
    new import_obsidian.Setting(contentEl).setName("Counter Type").addDropdown((dd) => {
      COUNTER_DEFINITIONS.forEach((def) => dd.addOption(def.type, def.name));
      dd.setValue(this.type).onChange((v) => {
        this.type = v;
        const def = COUNTER_DEFINITIONS.find((d) => d.type === this.type);
        if (!(def == null ? void 0 : def.hasParameter)) {
          this.parameter = void 0;
          paramMount.empty();
        } else {
          renderParam();
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Property Name").addText(
      (t) => t.setPlaceholder("Type the exact property name you want. e.g., word-count").setValue(this.property).onChange((v) => {
        this.property = ValidationHelper.sanitizePropertyName(v);
        if (this.property !== v)
          t.setValue(this.property);
      })
    );
    new import_obsidian.Setting(contentEl).setName("Enabled").addToggle((tg) => tg.setValue(this.enabled).onChange((v) => this.enabled = v));
    const paramMount = contentEl.createDiv({ cls: "countcraft-edit-param" });
    const renderParam = () => {
      var _a, _b;
      paramMount.empty();
      const def = COUNTER_DEFINITIONS.find((d) => d.type === this.type);
      if (!(def == null ? void 0 : def.hasParameter))
        return;
      const s = new import_obsidian.Setting(paramMount).setName(def.parameterName || "Parameter");
      if (def.parameterType === "number") {
        const min = (_a = def.parameterMin) != null ? _a : 1;
        const max = (_b = def.parameterMax) != null ? _b : 6;
        const init = typeof this.parameter === "number" ? Math.min(max, Math.max(min, this.parameter)) : min;
        this.parameter = init;
        s.addSlider(
          (sl) => sl.setLimits(min, max, 1).setValue(init).setDynamicTooltip().onChange((val) => this.parameter = val)
        );
      } else {
        s.addText(
          (t) => t.setValue(typeof this.parameter === "string" ? this.parameter : "").setPlaceholder("Enter value").onChange((val) => this.parameter = val)
        );
      }
    };
    renderParam();
    const footer = contentEl.createDiv({ cls: "modal-footer" });
    new import_obsidian.Setting(footer).addButton(
      (b) => b.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    ).addButton(
      (b) => b.setButtonText("Save").setCta().onClick(async () => {
        const updated = {
          ...this.config,
          type: this.type,
          property: this.property.trim(),
          enabled: this.enabled,
          parameter: this.parameter
        };
        const validation = ValidationHelper.validateCounterConfig(updated, this.plugin.settings.calculations);
        if (validation) {
          new import_obsidian.Notice(validation);
          return;
        }
        this.onSave(updated);
        this.close();
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};
var CountCraftSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "CountCraft Settings" });
    containerEl.createEl("p", {
      text: "Configure counting calculations and property mappings for your notes."
    });
    this.renderGeneralSettings(containerEl);
    this.renderCalculationsSection(containerEl);
    this.renderAddCalculationSection(containerEl);
    this.renderDebugSection(containerEl);
  }
  renderGeneralSettings(containerEl) {
    containerEl.createEl("h3", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Show ribbon icon").setDesc("Display a ribbon icon for quick access to calculations").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ribbonEnabled).onChange(async (value) => {
        this.plugin.settings.ribbonEnabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.ensureRibbonIcon();
        } else {
          this.plugin.removeRibbonIcon();
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto calculate on file save").setDesc("Automatically run calculations when a file is saved (experimental)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCalculate).onChange(async (value) => {
        this.plugin.settings.autoCalculate = value;
        await this.plugin.saveSettings();
      })
    );
  }
  renderCalculationsSection(containerEl) {
    const calculationsContainer = containerEl.createDiv();
    calculationsContainer.createEl("h3", { text: "Configured Calculations" });
    if (this.plugin.settings.calculations.length === 0) {
      calculationsContainer.createEl("p", {
        text: "No calculations configured. Add your first calculation below.",
        cls: "setting-item-description"
      });
      return;
    }
    this.plugin.settings.calculations.forEach((config, index) => {
      this.renderCalculationItem(calculationsContainer, config, index);
    });
  }
  renderCalculationItem(container, config, index) {
    const settingItem = new import_obsidian.Setting(container);
    const counterDef = COUNTER_DEFINITIONS.find((def) => def.type === config.type);
    const displayName = counterDef ? counterDef.name : config.type;
    let description = `Maps to property: ${config.property}`;
    if (config.parameter !== void 0) {
      description += ` (Parameter: ${config.parameter})`;
    }
    settingItem.setName(displayName).setDesc(description).addToggle(
      (toggle) => toggle.setValue(config.enabled).onChange(async (value) => {
        config.enabled = value;
        await this.plugin.saveSettings();
        DebugLogger.log(`${displayName} ${value ? "enabled" : "disabled"}`);
      })
    ).addButton(
      (button) => button.setButtonText("Edit").setTooltip("Edit this calculation").onClick(() => {
        this.editCalculation(config, index);
      })
    ).addButton(
      (button) => button.setButtonText("Delete").setTooltip("Remove this calculation").setWarning().onClick(async () => {
        if (confirm(`Are you sure you want to delete the "${displayName}" calculation?`)) {
          this.plugin.settings.calculations.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice(`Deleted calculation: ${displayName}`);
        }
      })
    );
  }
  renderAddCalculationSection(containerEl) {
    containerEl.createEl("h3", { text: "Add New Calculation" });
    const formContainer = containerEl.createDiv({ cls: "countcraft-add-form" });
    let selectedType = null;
    let propertyName = "";
    let parameter = void 0;
    let propertyNameInput = null;
    let propertyNameTouched = false;
    const paramMount = formContainer.createDiv({ cls: "countcraft-param-mount" });
    new import_obsidian.Setting(formContainer).setName("Counter Type").setDesc("Select the type of calculation to perform").addDropdown((dropdown) => {
      dropdown.addOption("", "Select a counter type...");
      COUNTER_DEFINITIONS.forEach((def) => {
        dropdown.addOption(def.type, def.name);
      });
      dropdown.onChange((value) => {
        selectedType = value || null;
        if (!propertyNameTouched && (!propertyName || propertyName.length === 0) && selectedType && DEFAULT_PROPERTY_NAMES[selectedType]) {
          propertyName = DEFAULT_PROPERTY_NAMES[selectedType];
          if (propertyNameInput)
            propertyNameInput.setValue(propertyName);
        }
        renderAddParam();
      });
    });
    new import_obsidian.Setting(formContainer).setName("Property Name").setDesc("Name of the property to store the calculation result").addText((text) => {
      propertyNameInput = text;
      text.setPlaceholder("Enter property name").onChange((value) => {
        propertyNameTouched = true;
        const trimmed = ValidationHelper.sanitizePropertyName(value);
        propertyName = trimmed;
        if (trimmed !== value) {
          text.setValue(trimmed);
        }
      });
    });
    const renderAddParam = () => {
      var _a, _b;
      paramMount.empty();
      if (!selectedType) {
        parameter = void 0;
        return;
      }
      const def = COUNTER_DEFINITIONS.find((d) => d.type === selectedType);
      if (!(def == null ? void 0 : def.hasParameter)) {
        parameter = void 0;
        return;
      }
      ;
      const s = new import_obsidian.Setting(paramMount).setName(def.parameterName || "Parameter");
      if (def.parameterType === "number") {
        const min = (_a = def.parameterMin) != null ? _a : 1;
        const max = (_b = def.parameterMax) != null ? _b : 6;
        const init = typeof parameter === "number" ? Math.min(max, Math.max(min, parameter)) : min;
        parameter = init;
        s.addSlider(
          (s1) => s1.setLimits(min, max, 1).setValue(init).setDynamicTooltip().onChange((val) => parameter = val)
        );
      } else {
        s.addText(
          (t) => t.setPlaceholder("Enter parameter value").onChange((val) => parameter = val)
        );
      }
    };
    new import_obsidian.Setting(formContainer).addButton(
      (button) => button.setButtonText("Add Calculation").setCta().onClick(async () => {
        await this.addNewCalculation(selectedType, propertyName, parameter);
      })
    );
    formContainer.createEl("p", {
      text: "Property names will be automatically sanitized and created as number type properties.",
      cls: "setting-item-description"
    });
  }
  updateParameterInput(selectedType, container, onParameterChange) {
    const existingParam = container.querySelector(".countcraft-parameter-setting");
    if (existingParam) {
      existingParam.remove();
    }
    if (!selectedType)
      return;
    const counterDef = COUNTER_DEFINITIONS.find((def) => def.type === selectedType);
    if (!(counterDef == null ? void 0 : counterDef.hasParameter))
      return;
    const parameterSetting = new import_obsidian.Setting(container);
    parameterSetting.settingEl.addClass("countcraft-parameter-setting");
    parameterSetting.setName(counterDef.parameterName || "Parameter").setDesc(`Required parameter for ${counterDef.name}`);
    if (counterDef.parameterType === "number") {
      parameterSetting.addSlider(
        (slider) => slider.setLimits(counterDef.parameterMin || 1, counterDef.parameterMax || 6, 1).setValue(counterDef.parameterMin || 1).setDynamicTooltip().onChange((value) => {
          onParameterChange(value);
        })
      );
    } else {
      parameterSetting.addText(
        (text) => text.setPlaceholder("Enter parameter value").onChange((value) => {
          onParameterChange(value);
        })
      );
    }
  }
  async addNewCalculation(selectedType, propertyName, parameter) {
    var _a;
    if (!selectedType) {
      new import_obsidian.Notice("Please select a counter type");
      return;
    }
    if (!propertyName.trim()) {
      new import_obsidian.Notice("Please enter a property name");
      return;
    }
    const newConfig = {
      id: ValidationHelper.generateCounterId(),
      name: ((_a = COUNTER_DEFINITIONS.find((def) => def.type === selectedType)) == null ? void 0 : _a.name) || selectedType,
      type: selectedType,
      property: propertyName.trim(),
      enabled: true,
      parameter
    };
    const validation = ValidationHelper.validateCounterConfig(newConfig, this.plugin.settings.calculations);
    if (validation) {
      new import_obsidian.Notice(validation);
      return;
    }
    this.plugin.settings.calculations.push(newConfig);
    await this.plugin.saveSettings();
    this.display();
    new import_obsidian.Notice(`Added calculation: ${newConfig.name}`);
    DebugLogger.log("New calculation added:", newConfig);
  }
  editCalculation(config, index) {
    new EditCalculationModal(this.app, this.plugin, config, async (updated) => {
      this.plugin.settings.calculations[index] = updated;
      await this.plugin.saveSettings();
      this.display();
      new import_obsidian.Notice("Calculation updated");
    }).open();
  }
  renderDebugSection(containerEl) {
    containerEl.createEl("h3", { text: "Debug Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable debug logging").setDesc("Show detailed logs in the console for troubleshooting").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        DebugLogger.enable(value);
        await this.plugin.saveSettings();
        if (value) {
          new import_obsidian.Notice("Debug logging enabled - check console for details");
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test calculations").setDesc("Run calculations on the current active file for testing").addButton(
      (button) => button.setButtonText("Test Now").onClick(async () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian.Notice("No active file to test with");
          return;
        }
        try {
          const results = await this.plugin.counter.calculateFileStats(
            activeFile,
            this.plugin.settings.calculations
          );
          const message = Object.keys(results).length > 0 ? `Test completed! Updated ${Object.keys(results).length} properties.` : "Test completed, but no calculations were enabled.";
          new import_obsidian.Notice(message);
        } catch (error) {
          const msg = errorMessage(error);
          new import_obsidian.Notice(`Test failed: ${msg}`);
          DebugLogger.error("Test calculation failed:", msg);
        }
      })
    );
  }
};

// src/counter.ts
var import_obsidian2 = require("obsidian");
var CountCraftCounter = class {
  constructor(app) {
    this.app = app;
    this.propertyManager = new PropertyManager(app);
    this.cacheHelper = new CacheHelper(app);
  }
  /**
   * Calculates statistics for a file based on enabled counter configurations
   */
  async calculateFileStats(file, counterConfigs) {
    DebugLogger.log(`Calculating stats for file: ${file.path}`);
    const enabledConfigs = counterConfigs.filter((config) => config.enabled);
    if (enabledConfigs.length === 0) {
      DebugLogger.log("No enabled counter configurations found");
      return {};
    }
    try {
      const content = await this.cacheHelper.getFileBody(file);
      const fileStats = this.calculateBaseStats(content);
      const results = {};
      for (const config of enabledConfigs) {
        try {
          const value = this.getCountForType(config.type, fileStats, config.parameter);
          await this.propertyManager.ensurePropertyExists(config.property);
          await this.propertyManager.updateFileProperty(file, config.property, value);
          results[config.property] = value;
          DebugLogger.log(`Updated ${config.property}: ${value}`);
        } catch (error) {
          const msg = errorMessage(error);
          DebugLogger.error(`Error processing config ${config.id}:`, msg);
          new import_obsidian2.Notice(`Error calculating ${config.name}: ${msg}`);
        }
      }
      DebugLogger.log("Calculation completed", results);
      return results;
    } catch (error) {
      const msg = errorMessage(error);
      DebugLogger.error("Error calculating file stats:", msg);
      new import_obsidian2.Notice(`Error calculating statistics: ${msg}`);
      throw msg;
    }
  }
  /**
   * Calculates base statistics for file content
   */
  calculateBaseStats(content) {
    const wordCount = TextAnalyzer.countWords(content);
    const charCountWithSpaces = TextAnalyzer.countCharactersWithSpaces(content);
    const charCountWithoutSpaces = TextAnalyzer.countCharactersWithoutSpaces(content);
    const lineCount = TextAnalyzer.countLines(content);
    const headingsByLevel = TextAnalyzer.countHeadingsByLevel(content);
    const headingCount = Object.values(headingsByLevel).reduce((sum, count) => sum + count, 0);
    return {
      wordCount,
      charCountWithSpaces,
      charCountWithoutSpaces,
      lineCount,
      headingCount,
      headingsByLevel
    };
  }
  /**
   * Gets count value for specific counter type
   */
  getCountForType(type, stats, parameter) {
    switch (type) {
      case "wordCount" /* WORD_COUNT */:
        return stats.wordCount;
      case "charCountWithSpaces" /* CHAR_COUNT_WITH_SPACES */:
        return stats.charCountWithSpaces;
      case "charCountWithoutSpaces" /* CHAR_COUNT_WITHOUT_SPACES */:
        return stats.charCountWithoutSpaces;
      case "lineCount" /* LINE_COUNT */:
        return stats.lineCount;
      case "headingCount" /* HEADING_COUNT */:
        return stats.headingCount;
      case "headingLevelCount" /* HEADING_LEVEL_COUNT */:
        if (parameter === void 0) {
          throw new Error("Heading level parameter is required");
        }
        const level = Number(parameter);
        if (isNaN(level) || level < 1 || level > 6) {
          throw new Error("Heading level must be between 1 and 6");
        }
        return stats.headingsByLevel[level] || 0;
      default:
        throw new Error(`Unknown counter type: ${type}`);
    }
  }
  /**
   * Calculates statistics for all files in vault (batch operation)
   */
  async calculateAllFiles(counterConfigs) {
    const files = this.app.vault.getMarkdownFiles();
    const enabledConfigs = counterConfigs.filter((config) => config.enabled);
    if (enabledConfigs.length === 0) {
      new import_obsidian2.Notice("No counter configurations are enabled");
      return;
    }
    let processed = 0;
    const total = files.length;
    new import_obsidian2.Notice(`Starting batch calculation for ${total} files...`);
    for (const file of files) {
      try {
        await this.calculateFileStats(file, counterConfigs);
        processed++;
        if (total > 10 && processed % Math.ceil(total / 10) === 0) {
          new import_obsidian2.Notice(`Progress: ${processed}/${total} files processed`);
        }
      } catch (error) {
        const msg = errorMessage(error);
        DebugLogger.error(`Error processing file ${file.path}:`, msg);
      }
    }
    new import_obsidian2.Notice(`Batch calculation completed: ${processed}/${total} files processed`);
  }
  /**
   * Calculates statistics using cached metadata where possible for better performance
   */
  async calculateFileStatsFromCache(file, counterConfigs) {
    const enabledConfigs = counterConfigs.filter((config) => config.enabled);
    if (enabledConfigs.length === 0) {
      return {};
    }
    const cachedMetadata = this.cacheHelper.getCachedMetadata(file);
    let cachedResults = {};
    if (cachedMetadata) {
      const cachedHeadings = this.cacheHelper.getCachedHeadings(file);
      if (cachedHeadings.length > 0) {
        const headingsByLevel = {};
        cachedHeadings.forEach((heading) => {
          headingsByLevel[heading.level] = (headingsByLevel[heading.level] || 0) + 1;
        });
        cachedResults.headingsByLevel = headingsByLevel;
        cachedResults.headingCount = Object.values(headingsByLevel).reduce((sum, count) => sum + count, 0);
      }
    }
    const needsContent = enabledConfigs.some(
      (config) => config.type === "wordCount" /* WORD_COUNT */ || config.type === "charCountWithSpaces" /* CHAR_COUNT_WITH_SPACES */ || config.type === "charCountWithoutSpaces" /* CHAR_COUNT_WITHOUT_SPACES */ || config.type === "lineCount" /* LINE_COUNT */ || config.type === "headingCount" /* HEADING_COUNT */ && !cachedResults.headingCount || config.type === "headingLevelCount" /* HEADING_LEVEL_COUNT */ && !cachedResults.headingsByLevel
    );
    let fullStats;
    if (needsContent) {
      const content = await this.cacheHelper.getFileBody(file);
      fullStats = this.calculateBaseStats(content);
    } else {
      fullStats = {
        wordCount: 0,
        charCountWithSpaces: 0,
        charCountWithoutSpaces: 0,
        lineCount: 0,
        headingCount: cachedResults.headingCount || 0,
        headingsByLevel: cachedResults.headingsByLevel || {}
      };
    }
    const results = {};
    for (const config of enabledConfigs) {
      try {
        const value = this.getCountForType(config.type, fullStats, config.parameter);
        await this.propertyManager.ensurePropertyExists(config.property);
        await this.propertyManager.updateFileProperty(file, config.property, value);
        results[config.property] = value;
      } catch (error) {
        const msg = errorMessage(error);
        DebugLogger.error(`Error processing cached config ${config.id}:`, msg);
      }
    }
    return results;
  }
  /**
   * Validates if file is suitable for processing
   */
  isFileProcessable(file) {
    if (file.extension !== "md") {
      return false;
    }
    if (!this.app.vault.adapter.exists(file.path)) {
      return false;
    }
    return true;
  }
  /**
   * Gets preview statistics without updating properties
   */
  async getPreviewStats(file) {
    if (!this.isFileProcessable(file)) {
      throw new Error("File is not processable");
    }
    const content = await this.cacheHelper.getFileBody(file);
    return this.calculateBaseStats(content);
  }
};

// src/main.ts
var CountCraftPlugin = class extends import_obsidian3.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = DEFAULT_SETTINGS;
    this.ribbonIconEl = null;
    this.counter = new CountCraftCounter(app);
  }
  async onload() {
    await this.loadSettings();
    DebugLogger.enable(this.settings.debugMode);
    DebugLogger.log("CountCraft plugin loading...");
    this.counter = new CountCraftCounter(this.app);
    this.addSettingTab(new CountCraftSettingsTab(this.app, this));
    this.addCommands();
    if (this.settings.ribbonEnabled) {
      this.ensureRibbonIcon();
    }
    this.registerEventListeners();
    DebugLogger.log("CountCraft plugin loaded successfully");
    if (this.settings.calculations.length === 0) {
      new import_obsidian3.Notice("CountCraft: Open settings to configure your first calculation!", 5e3);
    }
  }
  async onunload() {
    DebugLogger.log("CountCraft plugin unloading...");
    this.removeRibbonIcon();
  }
  /**
   * Load plugin settings from disk
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save plugin settings to disk
   */
  async saveSettings() {
    await this.saveData(this.settings);
    DebugLogger.log("Settings saved:", this.settings);
  }
  /**
   * Add plugin commands
   */
  addCommands() {
    this.addCommand({
      id: COMMAND_IDS.CALCULATE,
      name: "Calculate Statistics for Current Note",
      callback: async () => {
        await this.runCalculationCommand();
      }
    });
    this.addCommand({
      id: "calculate-all-files",
      name: "Calculate Statistics for All Files",
      callback: async () => {
        await this.runBatchCalculationCommand();
      }
    });
    this.addCommand({
      id: COMMAND_IDS.OPEN_SETTINGS,
      name: "Open CountCraft Settings",
      callback: () => {
        this.openSettings();
      }
    });
    this.addCommand({
      id: "preview-stats",
      name: "Preview Statistics (No Property Updates)",
      callback: async () => {
        await this.previewStatsCommand();
      }
    });
  }
  /**
   * Add ribbon icon
   */
  ensureRibbonIcon() {
    if (this.ribbonIconEl) {
      return;
    }
    this.ribbonIconEl = this.addRibbonIcon(
      ICONS.RIBBON,
      "CountCraft: Calculate Statistics",
      async () => {
        await this.runCalculationCommand();
      }
    );
    DebugLogger.log("Ribbon icon added");
  }
  /**
   * Remove ribbon icon
   */
  removeRibbonIcon() {
    if (this.ribbonIconEl) {
      this.ribbonIconEl.remove();
      this.ribbonIconEl = null;
      DebugLogger.log("Ribbon icon removed");
    }
  }
  /**
   * Register event listeners
   */
  registerEventListeners() {
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (this.settings.autoCalculate && file instanceof import_obsidian3.TFile && file.extension === "md") {
          setTimeout(async () => {
            try {
              await this.counter.calculateFileStatsFromCache(file, this.settings.calculations);
              DebugLogger.log(`Auto-calculated stats for: ${file.path}`);
            } catch (error) {
              const msg = errorMessage(error);
              DebugLogger.error("Auto-calculation failed:", msg);
            }
          }, 500);
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("resolved", () => {
        DebugLogger.log("Metadata cache resolved");
      })
    );
  }
  /**
   * Run calculation command for active file
   */
  async runCalculationCommand() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice(MESSAGES.NO_ACTIVE_FILE);
      return;
    }
    if (!this.counter.isFileProcessable(activeFile)) {
      new import_obsidian3.Notice("Selected file cannot be processed (must be a markdown file)");
      return;
    }
    const enabledCalculations = this.settings.calculations.filter((calc) => calc.enabled);
    if (enabledCalculations.length === 0) {
      new import_obsidian3.Notice("No calculations are enabled. Please configure calculations in settings.");
      this.openSettings();
      return;
    }
    try {
      const notice = new import_obsidian3.Notice("Calculating statistics...", 0);
      const results = await this.counter.calculateFileStats(activeFile, this.settings.calculations);
      notice.hide();
      if (Object.keys(results).length > 0) {
        const resultText = Object.entries(results).map(([prop, value]) => `${prop}: ${value}`).join(", ");
        new import_obsidian3.Notice(`${MESSAGES.CALCULATION_COMPLETE} ${resultText}`, 4e3);
      } else {
        new import_obsidian3.Notice("No calculations were performed (all may be disabled)");
      }
    } catch (error) {
      const msg = errorMessage(error);
      new import_obsidian3.Notice(`Calculation failed: ${msg}`);
      DebugLogger.error("Calculation command failed:", msg);
    }
  }
  /**
   * Run batch calculation command for all files
   */
  async runBatchCalculationCommand() {
    const enabledCalculations = this.settings.calculations.filter((calc) => calc.enabled);
    if (enabledCalculations.length === 0) {
      new import_obsidian3.Notice("No calculations are enabled. Please configure calculations in settings.");
      this.openSettings();
      return;
    }
    const files = this.app.vault.getMarkdownFiles();
    if (files.length === 0) {
      new import_obsidian3.Notice("No markdown files found in vault");
      return;
    }
    const confirmMessage = `This will calculate statistics for ${files.length} files. This may take some time. Continue?`;
    if (!confirm(confirmMessage)) {
      return;
    }
    try {
      await this.counter.calculateAllFiles(this.settings.calculations);
    } catch (error) {
      const msg = errorMessage(error);
      new import_obsidian3.Notice(`Batch calculation failed: ${msg}`);
      DebugLogger.error("Batch calculation failed:", msg);
    }
  }
  /**
   * Preview statistics without updating properties
   */
  async previewStatsCommand() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice(MESSAGES.NO_ACTIVE_FILE);
      return;
    }
    if (!this.counter.isFileProcessable(activeFile)) {
      new import_obsidian3.Notice("Selected file cannot be processed (must be a markdown file)");
      return;
    }
    try {
      const stats = await this.counter.getPreviewStats(activeFile);
      let message = `Statistics for ${activeFile.name}:
`;
      message += `Words: ${stats.wordCount}
`;
      message += `Characters (with spaces): ${stats.charCountWithSpaces}
`;
      message += `Characters (without spaces): ${stats.charCountWithoutSpaces}
`;
      message += `Lines: ${stats.lineCount}
`;
      message += `Headings: ${stats.headingCount}`;
      if (Object.keys(stats.headingsByLevel).length > 0) {
        message += "\nHeadings by level:";
        Object.entries(stats.headingsByLevel).forEach(([level, count]) => {
          message += `
  Level ${level}: ${count}`;
        });
      }
      new import_obsidian3.Notice(message, 8e3);
      console.log("File Statistics Preview:", stats);
    } catch (error) {
      const msg = errorMessage(error);
      new import_obsidian3.Notice(`Preview failed: ${msg}`);
      DebugLogger.error("Preview command failed:", msg);
    }
  }
  /**
   * Open plugin settings
   */
  openSettings() {
    const settingTab = this.app.setting;
    if (settingTab) {
      settingTab.open();
      settingTab.openTabById(this.manifest.id);
    }
  }
  /**
   * Handle external settings changes
   */
  async onExternalSettingsChange() {
    await this.loadSettings();
    DebugLogger.enable(this.settings.debugMode);
    DebugLogger.log("External settings change detected");
  }
  /**
   * Get current plugin version
   */
  getVersion() {
    return this.manifest.version;
  }
  /**
   * Get plugin status information
   */
  getStatus() {
    return {
      calculationsCount: this.settings.calculations.length,
      enabledCount: this.settings.calculations.filter((calc) => calc.enabled).length,
      ribbonEnabled: this.settings.ribbonEnabled,
      autoCalculateEnabled: this.settings.autoCalculate
    };
  }
  /**
   * Export settings for backup
   */
  exportSettings() {
    return JSON.stringify(this.settings, null, 2);
  }
  /**
   * Import settings from backup
   */
  async importSettings(settingsJson) {
    try {
      const importedSettings = JSON.parse(settingsJson);
      if (!this.validateImportedSettings(importedSettings)) {
        throw new Error("Invalid settings format");
      }
      this.settings = { ...DEFAULT_SETTINGS, ...importedSettings };
      await this.saveSettings();
      if (this.settings.ribbonEnabled) {
        this.ensureRibbonIcon();
      } else {
        this.removeRibbonIcon();
      }
      DebugLogger.enable(this.settings.debugMode);
      new import_obsidian3.Notice("Settings imported successfully");
      return true;
    } catch (error) {
      const msg = errorMessage(error);
      new import_obsidian3.Notice(`Failed to import settings: ${msg}`);
      DebugLogger.error("Settings import failed:", msg);
      return false;
    }
  }
  /**
   * Validate imported settings structure
   */
  validateImportedSettings(settings) {
    if (typeof settings !== "object" || settings === null) {
      return false;
    }
    if (settings.calculations && !Array.isArray(settings.calculations)) {
      return false;
    }
    if (settings.ribbonEnabled !== void 0 && typeof settings.ribbonEnabled !== "boolean") {
      return false;
    }
    if (settings.autoCalculate !== void 0 && typeof settings.autoCalculate !== "boolean") {
      return false;
    }
    if (settings.debugMode !== void 0 && typeof settings.debugMode !== "boolean") {
      return false;
    }
    if (settings.calculations) {
      for (const calc of settings.calculations) {
        if (!calc.id || !calc.type || !calc.property || typeof calc.enabled !== "boolean") {
          return false;
        }
      }
    }
    return true;
  }
};
